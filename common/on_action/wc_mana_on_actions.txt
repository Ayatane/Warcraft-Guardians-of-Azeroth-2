wc_on_mana_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_mana_variable }

			wc_change_mana_by_value_effect = {
				CHANGE = add
				VALUE = wc_mana_regeneration_value
			}
		}
		else = {
			set_variable = { name = wc_current_mana_variable value = wc_max_mana_value }
			wc_recalculate_prowess_from_mana_effect = yes
		}

		trigger_event = { on_action = wc_on_mana_regeneration months = 1 }
	}
}

wc_on_health_regeneration = {
	effect = {
		if = {
			limit = { has_variable = wc_current_hp_variable }
			wc_change_hp_by_value_effect = {
				CHANGE = add
				VALUE = wc_hp_replenishment_value
			}
		}

		else = {
			set_variable = { name = wc_current_hp_variable value = wc_hp_capacity_value }
		}

		trigger_event = { on_action = wc_on_health_regeneration months = 1 }
	}
}

wc_on_spell_progression = {
	effect = {
		every_in_list = {
			variable = current_spells_casting
			save_scope_as = casting_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:casting_spell
					EFFECT = add_spell_progression_effect
				}
			}
		}
		every_in_list = {
			variable = spells_cd
			save_scope_as = cd_spell
			root = {
				execute_scoped_spell_effect = {
					SPELL = scope:cd_spell
					EFFECT = update_spell_cooldown_effect
				}
			}
		}
		if = { # so it doesnt double count spells
			limit = {
				NOT = { exists = var:spell_loop_on }
			}
			set_variable = { name = spell_loop_on value = yes }
		}
		trigger_event = { on_action = wc_on_spell_progression days = 1 }
	}
}

## root is the caster
### before removing the mana of the spell cast and doing anything
### Variable prefix: current_
### Variables: spell_name, rank, targets_list (variable list), recipient, elemental_type (for elemental type), class, target_type
### e.g. var:current_spell_type = flag:decay
wc_on_spell_cast_started = {

}

## root is the caster
### upon finishing the spell cast, before setting cd or anything ###
### Variable prefix: casted_
### Variables: spell, recipient, targets_list (variable list), rank, type (for elemental type), class, target_type
### e.g. var:casted_spell = flag:lava_lash
wc_on_spell_cast_finish = {
	effect = {
		# Send interface message to caster
		send_interface_message = {
			title = spell_cast_complete_title
			custom_tooltip = spell_cast_complete_desc
		}

		if = { # automatically used
			limit = {
				has_character_modifier = wc_backdraft_proc
			}
			remove_character_modifier = wc_backdraft_proc
		}

		# Send interface message to target 
		if = {
			limit = { 
				exists = var:casted_recipient
				var:casted_target_type = flag:character
				NOT = { var:casted_recipient = root }
			}
			var:casted_recipient = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}
		else_if = {
			limit = { 
				exists = var:casted_recipient
				var:casted_target_type = flag:title
				NOT = { var:casted_recipient.holder = root }
			}
			var:casted_recipient.holder = {
				save_temporary_scope_as = castee
			}
			scope:castee = {
				root = {
					save_temporary_scope_as = caster
				}
				set_variable = {
					name = on_casted_spell
					value = root.var:casted_spell
				}
				send_interface_message = {
					title = spell_cast_on_you_title
					custom_tooltip = spell_cast_on_you_desc
				}
			}
		}
		else_if = {
			limit = { 
				has_variable_list = casted_targets_list
				var:casted_target_type = flag:character_list
			}
			every_in_list = {
				variable = spell_targets_list
				save_scope_as = new_target
				if = {
					limit = {
						NOT = { scope:new_target = root }
					}
					scope:new_target = {
						set_variable = {
							name = on_casted_spell
							value = root.var:casted_spell
						}
						send_interface_message = {
							title = spell_cast_on_you_title
							custom_tooltip = spell_cast_on_you_desc
						}
					}
				}
			}
		}
		else_if = {
			limit = { 
				has_variable_list = casted_targets_list
				var:casted_target_type = flag:title_list
			}
			every_in_list = {
				variable = spell_targets_list
				save_scope_as = new_target
				if = {
					limit = {
						NOT = { scope:new_target.holder = root }
					}
					scope:new_target.holder = {
						set_variable = {
							name = on_casted_spell
							value = root.var:casted_spell
						}
						send_interface_message = {
							title = spell_cast_on_you_title
							custom_tooltip = spell_cast_on_you_desc
						}
					}
				}
			}
		}

		## BACKDRAFT
		if = {
			limit = {
				exists = var:casted_recipient # Is it on a title
				var:casted_target_type = flag:title
				OR = { # is it the required spell type
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
					var:casted_class = flag:order
				}
			}
			var:casted_recipient.title_province = {
				save_scope_as = recipient
			}
			if = {
				limit = {
					scope:recipient = { # does it have a monitor
						has_variable = var:backdraft_monitor
					}
				}
				scope:recipient = {
					var:backdraft_monitor = {
						save_scope_as = monitor
					}
				}
				scope:monitor = {
					scope:recipient = {
						save_scope_as = current_province
					}
					execute_scoped_spell_effect = {
						SPELL = root.var:current_spell_name
						EFFECT = backdraft_proc_effect
					}
				}
			}
			
			
		}
		else_if = {
			limit = {
				var:casted_target_type = flag:title_list
				OR = { # is it the required spell type
					var:casted_class = flag:elemental_fire
					var:casted_class = flag:elemental_earth
					var:casted_class = flag:elemental_water
					var:casted_class = flag:elemental_air
					var:casted_class = flag:disorder
					var:casted_class = flag:order
				}
			}
			every_in_list = {
				variable = current_targets_list
				limit = {
					title_province = { has_variable = var:backdraft_monitor }
				}
				save_scope_as = provin
				title_province = {
					var:backdraft_monitor = {
						save_Scope_as = monitor
					}
				}
				scope:monitor = {
					scope:provin = {
						save_scope_as = current_province
					}
					execute_scoped_spell_effect = {
						SPELL = root.var:current_spell_name
						EFFECT = backdraft_proc_effect
					}
				}
			}
		}
	}
}